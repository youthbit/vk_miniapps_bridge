{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\n\nfunction prepareSize(size) {\n  return {\n    url: size.url || size.src || '',\n    width: size.width,\n    height: size.height\n  };\n}\n\nfunction computeSize(sizes, minWidth) {\n  var minHeight = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null; // Do nothing if sizes contains only 1 item\n\n  if (sizes.length === 1) {\n    return sizes[0];\n  } // Sorting in ascending order\n\n\n  var sorted = _toConsumableArray(sizes).sort(function (a, b) {\n    if (a.width < b.width) {\n      return -1;\n    }\n\n    if (a.width === b.width) {\n      return a.height > b.height ? 1 : -1;\n    }\n\n    return 1;\n  });\n\n  var matchesByWidth = sorted.filter(function (size) {\n    return size.width >= minWidth;\n  });\n\n  if (!matchesByWidth.length) {\n    // Biggest size\n    return sorted[sorted.length - 1];\n  }\n\n  if (!minHeight) {\n    return matchesByWidth[0];\n  } // Searching by height\n\n\n  for (var i = 0; i < matchesByWidth.length; i++) {\n    var size = matchesByWidth[i];\n\n    if (size.height >= minHeight) {\n      return size;\n    }\n  } // Sorting by height in ascending order\n\n\n  var sortedByHeight = matchesByWidth.sort(function (a, b) {\n    return a.height > b.height ? 1 : -1;\n  });\n  return sortedByHeight[sortedByHeight.length - 1];\n}\n/**\n * Searches for the smallest (?) suitable image from the sizes array.\n *\n * Or more precise, it returns:\n *   – if no suitable sizes (>= minWidth И >= minHeight): the biggest from all sizes;\n *   – there are any suitable (>= minWidth И >= minHeight): the smallest of the matching sizes;\n *\n * Returns null only in case of an empty/invalid array. The returned size can be smaller than minWidth or minHeight.\n *\n * The function doesn't take into about the retina screen (window.devicePixelRatio), so you have to calculate the right width/height from the outside to support it.\n *\n * WARN:\n * - does not reckon for letter-sizes (PhotosPhotoSizesType).\n * - does not know how to search for the \"nearest\" size, or the maximum image (there is a hack with the `Infinity` pass).\n *\n * @example\n *   getPhotoSize([{ width: 1, height: 1 }, { width: 3, height: 3 }], 1) // => 1,1\n *   getPhotoSize([{ width: 1, height: 1 }, { width: 3, height: 3 }], 2) // => 3,3\n *   getPhotoSize([{ width: 1, height: 1 }, { width: 3, height: 3 }], 4) // => 3,3\n *\n * See more examples in tests\n */\n\n\nexport function getPhotoSize(sizes, minWidth) {\n  var minHeight = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n  if (!Array.isArray(sizes) || !sizes.length) {\n    return null;\n  }\n\n  var size = computeSize(sizes, minWidth, minHeight);\n  return prepareSize(size);\n}","map":{"version":3,"mappings":";;AAaA,SAASA,WAAT,CAAqBC,IAArB,EAAqD;EACnD,OAAO;IACLC,GAAG,EAAED,IAAI,CAACC,GAALD,IAAYA,IAAI,CAACE,GAAjBF,IAAwB,EADxB;IAELG,KAAK,EAAEH,IAAI,CAACG,KAFP;IAGLC,MAAM,EAAEJ,IAAI,CAACI;EAHR,CAAP;AAKF;;AAEA,SAASC,WAAT,CACEC,KADF,EAEEC,QAFF,EAIiB;EAAA,IADfC,SAAwB,uEAAG,IACZ,EACf;;EACA,IAAIF,KAAK,CAACG,MAANH,KAAiB,CAArB,EAAwB;IACtB,OAAOA,KAAK,CAAC,CAAD,CAAZ;EACF,CAJe,CAMf;;;EACA,IAAMI,MAAM,GAAGC,mBAAIL,KAAJ,EAAWM,IAAX,CAAgB,UAACC,CAAD,EAAIC,CAAJ,EAAU;IACvC,IAAID,CAAC,CAACV,KAAFU,GAAUC,CAAC,CAACX,KAAhB,EAAuB;MACrB,OAAO,CAAC,CAAR;IACF;;IAEA,IAAIU,CAAC,CAACV,KAAFU,KAAYC,CAAC,CAACX,KAAlB,EAAyB;MACvB,OAAOU,CAAC,CAACT,MAAFS,GAAWC,CAAC,CAACV,MAAbS,GAAsB,CAAtBA,GAA0B,CAAC,CAAlC;IACF;;IAEA,OAAO,CAAP;EACD,CAVc,CAAf;;EAYA,IAAME,cAAc,GAAGL,MAAM,CAACM,MAAPN,CAAc,UAACV,IAAD,EAAK;IAAA,OAAKA,IAAI,CAACG,KAALH,IAAcO,QAAnB;EAA2B,CAA9CG,CAAvB;;EACA,IAAI,CAACK,cAAc,CAACN,MAApB,EAA4B;IAC1B;IACA,OAAOC,MAAM,CAACA,MAAM,CAACD,MAAPC,GAAgB,CAAjB,CAAb;EACF;;EAEA,IAAI,CAACF,SAAL,EAAgB;IACd,OAAOO,cAAc,CAAC,CAAD,CAArB;EACF,CA3Be,CA6Bf;;;EACA,KAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,cAAc,CAACN,MAAnC,EAA2CQ,CAAC,EAA5C,EAAgD;IAC9C,IAAMjB,IAAI,GAAGe,cAAc,CAACE,CAAD,CAA3B;;IACA,IAAIjB,IAAI,CAACI,MAALJ,IAAeQ,SAAnB,EAA8B;MAC5B,OAAOR,IAAP;IACF;EACF,CAnCe,CAqCf;;;EACA,IAAMkB,cAAc,GAAGH,cAAc,CAACH,IAAfG,CAAoB,UAACF,CAAD,EAAIC,CAAJ,EAAK;IAAA,OAAMD,CAAC,CAACT,MAAFS,GAAWC,CAAC,CAACV,MAAbS,GAAsB,CAAtBA,GAA0B,CAAC,CAAjC;EAAmC,CAA5DE,CAAvB;EAEA,OAAOG,cAAc,CAACA,cAAc,CAACT,MAAfS,GAAwB,CAAzB,CAArB;AACF;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,SAASC,YAAT,CACLb,KADK,EAELC,QAFK,EAIa;EAAA,IADlBC,SAAwB,uEAAG,IACT;;EAClB,IAAI,CAACY,KAAK,CAACC,OAAND,CAAcd,KAAdc,CAAD,IAAyB,CAACd,KAAK,CAACG,MAApC,EAA4C;IAC1C,OAAO,IAAP;EACF;;EAEA,IAAMT,IAAI,GAAGK,WAAW,CAACC,KAAD,EAAQC,QAAR,EAAkBC,SAAlB,CAAxB;EAEA,OAAOT,WAAW,CAACC,IAAD,CAAlB;AACF","names":["prepareSize","size","url","src","width","height","computeSize","sizes","minWidth","minHeight","length","sorted","_toConsumableArray","sort","a","b","matchesByWidth","filter","i","sortedByHeight","getPhotoSize","Array","isArray"],"sources":["/Users/pitus_anonimous/Desktop/youth_bit_hack/youth_bit_vk/node_modules/@vkontakte/vkjs/src/getPhotoSize.ts"],"sourcesContent":["export interface PhotoSizeLike {\n  width: number;\n  height: number;\n  url?: string;\n  src?: string;\n}\n\nexport interface PhotoSize {\n  url: string;\n  width: number;\n  height: number;\n}\n\nfunction prepareSize(size: PhotoSizeLike): PhotoSize {\n  return {\n    url: size.url || size.src || '',\n    width: size.width,\n    height: size.height,\n  };\n}\n\nfunction computeSize(\n  sizes: PhotoSizeLike[],\n  minWidth: number,\n  minHeight: number | null = null,\n): PhotoSizeLike {\n  // Do nothing if sizes contains only 1 item\n  if (sizes.length === 1) {\n    return sizes[0];\n  }\n\n  // Sorting in ascending order\n  const sorted = [...sizes].sort((a, b) => {\n    if (a.width < b.width) {\n      return -1;\n    }\n\n    if (a.width === b.width) {\n      return a.height > b.height ? 1 : -1;\n    }\n\n    return 1;\n  });\n\n  const matchesByWidth = sorted.filter((size) => size.width >= minWidth);\n  if (!matchesByWidth.length) {\n    // Biggest size\n    return sorted[sorted.length - 1];\n  }\n\n  if (!minHeight) {\n    return matchesByWidth[0];\n  }\n\n  // Searching by height\n  for (let i = 0; i < matchesByWidth.length; i++) {\n    const size = matchesByWidth[i];\n    if (size.height >= minHeight) {\n      return size;\n    }\n  }\n\n  // Sorting by height in ascending order\n  const sortedByHeight = matchesByWidth.sort((a, b) => (a.height > b.height ? 1 : -1));\n\n  return sortedByHeight[sortedByHeight.length - 1];\n}\n\n/**\n * Searches for the smallest (?) suitable image from the sizes array.\n *\n * Or more precise, it returns:\n *   – if no suitable sizes (>= minWidth И >= minHeight): the biggest from all sizes;\n *   – there are any suitable (>= minWidth И >= minHeight): the smallest of the matching sizes;\n *\n * Returns null only in case of an empty/invalid array. The returned size can be smaller than minWidth or minHeight.\n *\n * The function doesn't take into about the retina screen (window.devicePixelRatio), so you have to calculate the right width/height from the outside to support it.\n *\n * WARN:\n * - does not reckon for letter-sizes (PhotosPhotoSizesType).\n * - does not know how to search for the \"nearest\" size, or the maximum image (there is a hack with the `Infinity` pass).\n *\n * @example\n *   getPhotoSize([{ width: 1, height: 1 }, { width: 3, height: 3 }], 1) // => 1,1\n *   getPhotoSize([{ width: 1, height: 1 }, { width: 3, height: 3 }], 2) // => 3,3\n *   getPhotoSize([{ width: 1, height: 1 }, { width: 3, height: 3 }], 4) // => 3,3\n *\n * See more examples in tests\n */\nexport function getPhotoSize(\n  sizes: PhotoSizeLike[],\n  minWidth: number,\n  minHeight: number | null = null,\n): PhotoSize | null {\n  if (!Array.isArray(sizes) || !sizes.length) {\n    return null;\n  }\n\n  const size = computeSize(sizes, minWidth, minHeight);\n\n  return prepareSize(size);\n}\n"]},"metadata":{},"sourceType":"module"}