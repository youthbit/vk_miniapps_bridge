{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nvar _excluded = [\"children\", \"getScrollToLeft\", \"getScrollToRight\", \"showArrows\", \"arrowSize\", \"scrollAnimationDuration\", \"getRef\", \"className\"];\nimport * as React from 'react';\nimport { useAdaptivityHasPointer } from '../../hooks/useAdaptivityHasPointer';\nimport { HorizontalScrollArrow } from './HorizontalScrollArrow';\nimport { easeInOutSine } from '../../lib/fx';\nimport { useEventListener } from '../../hooks/useEventListener';\nimport { useExternRef } from '../../hooks/useExternRef';\nimport { classNames } from '@vkontakte/vkjs';\n/**\n * timing method\n */\n\nfunction now() {\n  return performance && performance.now ? performance.now() : Date.now();\n}\n/**\n * Округляем el.scrollLeft\n * https://github.com/VKCOM/VKUI/pull/2445\n */\n\n\nvar roundUpElementScrollLeft = function roundUpElementScrollLeft(el) {\n  return Math.ceil(el.scrollLeft);\n};\n/**\n * Код анимации скрола, на основе полифила: https://github.com/iamdustan/smoothscroll\n * Константа взята из полифила (468), на дизайн-ревью уточнили до 250\n * @var {number} SCROLL_ONE_FRAME_TIME время анимации скролла\n */\n\n\nvar SCROLL_ONE_FRAME_TIME = 250;\n\nfunction doScroll(_ref) {\n  var scrollElement = _ref.scrollElement,\n      getScrollPosition = _ref.getScrollPosition,\n      animationQueue = _ref.animationQueue,\n      onScrollToRightBorder = _ref.onScrollToRightBorder,\n      onScrollEnd = _ref.onScrollEnd,\n      onScrollStart = _ref.onScrollStart,\n      initialScrollWidth = _ref.initialScrollWidth,\n      _ref$scrollAnimationD = _ref.scrollAnimationDuration,\n      scrollAnimationDuration = _ref$scrollAnimationD === void 0 ? SCROLL_ONE_FRAME_TIME : _ref$scrollAnimationD;\n\n  if (!scrollElement || !getScrollPosition) {\n    return;\n  }\n  /**\n   * максимальное значение сдвига влево\n   */\n\n\n  var maxLeft = initialScrollWidth - scrollElement.offsetWidth;\n  var startLeft = roundUpElementScrollLeft(scrollElement);\n  var endLeft = getScrollPosition(startLeft);\n  onScrollStart();\n\n  if (endLeft >= maxLeft) {\n    onScrollToRightBorder();\n    endLeft = maxLeft;\n  }\n\n  var startTime = now();\n\n  (function scroll() {\n    if (!scrollElement) {\n      onScrollEnd();\n      return;\n    }\n\n    var time = now();\n    var elapsed = Math.min((time - startTime) / scrollAnimationDuration, 1);\n    var value = easeInOutSine(elapsed);\n    var currentLeft = startLeft + (endLeft - startLeft) * value;\n    scrollElement.scrollLeft = Math.ceil(currentLeft);\n\n    if (roundUpElementScrollLeft(scrollElement) !== Math.max(0, endLeft) && elapsed !== 1) {\n      requestAnimationFrame(scroll);\n      return;\n    }\n\n    onScrollEnd();\n    animationQueue.shift();\n\n    if (animationQueue.length > 0) {\n      animationQueue[0]();\n    }\n  })();\n}\n/**\n * @see https://vkcom.github.io/VKUI/#/HorizontalScroll\n */\n\n\nexport var HorizontalScroll = function HorizontalScroll(_ref2) {\n  var children = _ref2.children,\n      getScrollToLeft = _ref2.getScrollToLeft,\n      getScrollToRight = _ref2.getScrollToRight,\n      _ref2$showArrows = _ref2.showArrows,\n      showArrows = _ref2$showArrows === void 0 ? true : _ref2$showArrows,\n      _ref2$arrowSize = _ref2.arrowSize,\n      arrowSize = _ref2$arrowSize === void 0 ? 'l' : _ref2$arrowSize,\n      _ref2$scrollAnimation = _ref2.scrollAnimationDuration,\n      scrollAnimationDuration = _ref2$scrollAnimation === void 0 ? SCROLL_ONE_FRAME_TIME : _ref2$scrollAnimation,\n      getRef = _ref2.getRef,\n      className = _ref2.className,\n      restProps = _objectWithoutProperties(_ref2, _excluded);\n\n  var _React$useState = React.useState(false),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      canScrollLeft = _React$useState2[0],\n      setCanScrollLeft = _React$useState2[1];\n\n  var _React$useState3 = React.useState(false),\n      _React$useState4 = _slicedToArray(_React$useState3, 2),\n      canScrollRight = _React$useState4[0],\n      setCanScrollRight = _React$useState4[1];\n\n  var isCustomScrollingRef = React.useRef(false);\n  var scrollerRef = useExternRef(getRef);\n  var animationQueue = React.useRef([]);\n  var hasPointer = useAdaptivityHasPointer();\n  var scrollTo = React.useCallback(function (getScrollPosition) {\n    var scrollElement = scrollerRef.current;\n    animationQueue.current.push(function () {\n      var _scrollElement$firstE;\n\n      return doScroll({\n        scrollElement: scrollElement,\n        getScrollPosition: getScrollPosition,\n        animationQueue: animationQueue.current,\n        onScrollToRightBorder: function onScrollToRightBorder() {\n          return setCanScrollRight(false);\n        },\n        onScrollEnd: function onScrollEnd() {\n          return isCustomScrollingRef.current = false;\n        },\n        onScrollStart: function onScrollStart() {\n          return isCustomScrollingRef.current = true;\n        },\n        initialScrollWidth: (scrollElement === null || scrollElement === void 0 ? void 0 : (_scrollElement$firstE = scrollElement.firstElementChild) === null || _scrollElement$firstE === void 0 ? void 0 : _scrollElement$firstE.scrollWidth) || 0,\n        scrollAnimationDuration: scrollAnimationDuration\n      });\n    });\n\n    if (animationQueue.current.length === 1) {\n      animationQueue.current[0]();\n    }\n  }, [scrollAnimationDuration, scrollerRef]);\n  var scrollToLeft = React.useCallback(function () {\n    var getScrollPosition = getScrollToLeft !== null && getScrollToLeft !== void 0 ? getScrollToLeft : function (i) {\n      return i - scrollerRef.current.offsetWidth;\n    };\n    scrollTo(getScrollPosition);\n  }, [getScrollToLeft, scrollTo, scrollerRef]);\n  var scrollToRight = React.useCallback(function () {\n    var getScrollPosition = getScrollToRight !== null && getScrollToRight !== void 0 ? getScrollToRight : function (i) {\n      return i + scrollerRef.current.offsetWidth;\n    };\n    scrollTo(getScrollPosition);\n  }, [getScrollToRight, scrollTo, scrollerRef]);\n  var onscroll = React.useCallback(function () {\n    if (showArrows && hasPointer && scrollerRef.current && !isCustomScrollingRef.current) {\n      var scrollElement = scrollerRef.current;\n      setCanScrollLeft(scrollElement.scrollLeft > 0);\n      setCanScrollRight(roundUpElementScrollLeft(scrollElement) + scrollElement.offsetWidth < scrollElement.scrollWidth);\n    }\n  }, [hasPointer, scrollerRef, showArrows]);\n  var scrollEvent = useEventListener('scroll', onscroll);\n  React.useEffect(function () {\n    if (scrollerRef.current) {\n      scrollEvent.add(scrollerRef.current);\n    }\n  }, [scrollEvent, scrollerRef]);\n  React.useEffect(onscroll, [scrollerRef, children, onscroll]);\n  return /*#__PURE__*/React.createElement(\"div\", _extends({}, restProps, {\n    className: classNames(\"vkuiHorizontalScroll\", showArrows === 'always' && \"vkuiHorizontalScroll--withConstArrows\", className)\n  }), /*#__PURE__*/React.createElement(\"div\", {\n    className: \"vkuiHorizontalScroll__in\",\n    ref: scrollerRef\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    className: \"vkuiHorizontalScroll__in-wrapper\"\n  }, children)), showArrows && (hasPointer || hasPointer === undefined) && canScrollLeft && /*#__PURE__*/React.createElement(HorizontalScrollArrow, {\n    size: arrowSize,\n    direction: \"left\",\n    className: \"vkuiHorizontalScroll__arrowLeft\",\n    onClick: scrollToLeft\n  }), showArrows && (hasPointer || hasPointer === undefined) && canScrollRight && /*#__PURE__*/React.createElement(HorizontalScrollArrow, {\n    size: arrowSize,\n    direction: \"right\",\n    className: \"vkuiHorizontalScroll__arrowRight\",\n    onClick: scrollToRight\n  }));\n};","map":{"version":3,"mappings":"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","names":["React","useAdaptivityHasPointer","HorizontalScrollArrow","easeInOutSine","useEventListener","useExternRef","classNames","now","performance","Date","roundUpElementScrollLeft","el","Math","ceil","scrollLeft","SCROLL_ONE_FRAME_TIME","doScroll","_ref","scrollElement","getScrollPosition","animationQueue","onScrollToRightBorder","onScrollEnd","onScrollStart","initialScrollWidth","_ref$scrollAnimationD","scrollAnimationDuration","maxLeft","offsetWidth","startLeft","endLeft","startTime","scroll","time","elapsed","min","value","currentLeft","max","requestAnimationFrame","shift","length","HorizontalScroll","_ref2","children","getScrollToLeft","getScrollToRight","_ref2$showArrows","showArrows","_ref2$arrowSize","arrowSize","_ref2$scrollAnimation","getRef","className","restProps","useState","_React$useState2","canScrollLeft","setCanScrollLeft","_React$useState4","canScrollRight","setCanScrollRight","isCustomScrollingRef","useRef","scrollerRef","hasPointer","scrollTo","useCallback","current","push","firstElementChild","_scrollElement$firstE","scrollWidth","scrollToLeft","i","scrollToRight","onscroll","scrollEvent","useEffect","add","ref","undefined","size","direction","onClick"],"sources":["/Users/pitus_anonimous/Desktop/youth_bit_hack/youth_bit_vk/node_modules/@vkontakte/vkui/src/components/HorizontalScroll/HorizontalScroll.tsx"],"sourcesContent":["import * as React from 'react';\nimport { useAdaptivityHasPointer } from '../../hooks/useAdaptivityHasPointer';\nimport { HorizontalScrollArrow } from './HorizontalScrollArrow';\nimport { easeInOutSine } from '../../lib/fx';\nimport { useEventListener } from '../../hooks/useEventListener';\nimport { useExternRef } from '../../hooks/useExternRef';\nimport { HasRef } from '../../types';\nimport { classNames } from '@vkontakte/vkjs';\nimport styles from './HorizontalScroll.module.css';\n\ninterface ScrollContext {\n  scrollElement: HTMLElement | null;\n  scrollAnimationDuration: number;\n  animationQueue: VoidFunction[];\n  getScrollPosition: (currentPosition: number) => number;\n  onScrollToRightBorder: VoidFunction;\n  onScrollEnd: VoidFunction;\n  onScrollStart: VoidFunction;\n  /**\n   * Начальная ширина прокрутки.\n   * В некоторых случаях может отличаться от текущей ширины прокрутки из-за transforms: translate\n   */\n  initialScrollWidth: number;\n}\n\nexport type ScrollPositionHandler = (currentPosition: number) => number;\n\nexport interface HorizontalScrollProps\n  extends React.HTMLAttributes<HTMLDivElement>,\n    HasRef<HTMLDivElement> {\n  /**\n   * Функция для расчета величины прокрутки при клике на левую стрелку.\n   */\n  getScrollToLeft?: ScrollPositionHandler;\n  /**\n   * Функция для расчета величины прокрутки при клике на правую стрелку.\n   */\n  getScrollToRight?: ScrollPositionHandler;\n  arrowSize?: 'm' | 'l';\n  showArrows?: boolean | 'always';\n  scrollAnimationDuration?: number;\n}\n\n/**\n * timing method\n */\nfunction now() {\n  return performance && performance.now ? performance.now() : Date.now();\n}\n\n/**\n * Округляем el.scrollLeft\n * https://github.com/VKCOM/VKUI/pull/2445\n */\nconst roundUpElementScrollLeft = (el: HTMLElement) => Math.ceil(el.scrollLeft);\n\n/**\n * Код анимации скрола, на основе полифила: https://github.com/iamdustan/smoothscroll\n * Константа взята из полифила (468), на дизайн-ревью уточнили до 250\n * @var {number} SCROLL_ONE_FRAME_TIME время анимации скролла\n */\nconst SCROLL_ONE_FRAME_TIME = 250;\n\nfunction doScroll({\n  scrollElement,\n  getScrollPosition,\n  animationQueue,\n  onScrollToRightBorder,\n  onScrollEnd,\n  onScrollStart,\n  initialScrollWidth,\n  scrollAnimationDuration = SCROLL_ONE_FRAME_TIME,\n}: ScrollContext) {\n  if (!scrollElement || !getScrollPosition) {\n    return;\n  }\n\n  /**\n   * максимальное значение сдвига влево\n   */\n  const maxLeft = initialScrollWidth - scrollElement.offsetWidth;\n\n  let startLeft = roundUpElementScrollLeft(scrollElement);\n  let endLeft = getScrollPosition(startLeft);\n\n  onScrollStart();\n\n  if (endLeft >= maxLeft) {\n    onScrollToRightBorder();\n    endLeft = maxLeft;\n  }\n\n  const startTime = now();\n\n  (function scroll() {\n    if (!scrollElement) {\n      onScrollEnd();\n      return;\n    }\n\n    const time = now();\n    const elapsed = Math.min((time - startTime) / scrollAnimationDuration, 1);\n\n    const value = easeInOutSine(elapsed);\n\n    const currentLeft = startLeft + (endLeft - startLeft) * value;\n    scrollElement.scrollLeft = Math.ceil(currentLeft);\n\n    if (roundUpElementScrollLeft(scrollElement) !== Math.max(0, endLeft) && elapsed !== 1) {\n      requestAnimationFrame(scroll);\n      return;\n    }\n\n    onScrollEnd();\n    animationQueue.shift();\n    if (animationQueue.length > 0) {\n      animationQueue[0]();\n    }\n  })();\n}\n\n/**\n * @see https://vkcom.github.io/VKUI/#/HorizontalScroll\n */\nexport const HorizontalScroll = ({\n  children,\n  getScrollToLeft,\n  getScrollToRight,\n  showArrows = true,\n  arrowSize = 'l',\n  scrollAnimationDuration = SCROLL_ONE_FRAME_TIME,\n  getRef,\n  className,\n  ...restProps\n}: HorizontalScrollProps) => {\n  const [canScrollLeft, setCanScrollLeft] = React.useState(false);\n  const [canScrollRight, setCanScrollRight] = React.useState(false);\n\n  const isCustomScrollingRef = React.useRef(false);\n\n  const scrollerRef = useExternRef(getRef);\n\n  const animationQueue = React.useRef<VoidFunction[]>([]);\n\n  const hasPointer = useAdaptivityHasPointer();\n\n  const scrollTo = React.useCallback(\n    (getScrollPosition: ScrollPositionHandler) => {\n      const scrollElement = scrollerRef.current;\n\n      animationQueue.current.push(() =>\n        doScroll({\n          scrollElement,\n          getScrollPosition,\n          animationQueue: animationQueue.current,\n          onScrollToRightBorder: () => setCanScrollRight(false),\n          onScrollEnd: () => (isCustomScrollingRef.current = false),\n          onScrollStart: () => (isCustomScrollingRef.current = true),\n          initialScrollWidth: scrollElement?.firstElementChild?.scrollWidth || 0,\n          scrollAnimationDuration,\n        }),\n      );\n      if (animationQueue.current.length === 1) {\n        animationQueue.current[0]();\n      }\n    },\n    [scrollAnimationDuration, scrollerRef],\n  );\n\n  const scrollToLeft = React.useCallback(() => {\n    const getScrollPosition =\n      getScrollToLeft ?? ((i: number) => i - scrollerRef.current!.offsetWidth);\n    scrollTo(getScrollPosition);\n  }, [getScrollToLeft, scrollTo, scrollerRef]);\n\n  const scrollToRight = React.useCallback(() => {\n    const getScrollPosition =\n      getScrollToRight ?? ((i: number) => i + scrollerRef.current!.offsetWidth);\n    scrollTo(getScrollPosition);\n  }, [getScrollToRight, scrollTo, scrollerRef]);\n\n  const onscroll = React.useCallback(() => {\n    if (showArrows && hasPointer && scrollerRef.current && !isCustomScrollingRef.current) {\n      const scrollElement = scrollerRef.current;\n\n      setCanScrollLeft(scrollElement.scrollLeft > 0);\n      setCanScrollRight(\n        roundUpElementScrollLeft(scrollElement) + scrollElement.offsetWidth <\n          scrollElement.scrollWidth,\n      );\n    }\n  }, [hasPointer, scrollerRef, showArrows]);\n\n  const scrollEvent = useEventListener('scroll', onscroll);\n  React.useEffect(() => {\n    if (scrollerRef.current) {\n      scrollEvent.add(scrollerRef.current);\n    }\n  }, [scrollEvent, scrollerRef]);\n  React.useEffect(onscroll, [scrollerRef, children, onscroll]);\n\n  return (\n    <div\n      {...restProps}\n      className={classNames(\n        styles['HorizontalScroll'],\n        showArrows === 'always' && styles['HorizontalScroll--withConstArrows'],\n        className,\n      )}\n    >\n      <div className={styles['HorizontalScroll__in']} ref={scrollerRef}>\n        <div className={styles['HorizontalScroll__in-wrapper']}>{children}</div>\n      </div>\n      {showArrows && (hasPointer || hasPointer === undefined) && canScrollLeft && (\n        <HorizontalScrollArrow\n          size={arrowSize}\n          direction=\"left\"\n          className={styles['HorizontalScroll__arrowLeft']}\n          onClick={scrollToLeft}\n        />\n      )}\n      {showArrows && (hasPointer || hasPointer === undefined) && canScrollRight && (\n        <HorizontalScrollArrow\n          size={arrowSize}\n          direction=\"right\"\n          className={styles['HorizontalScroll__arrowRight']}\n          onClick={scrollToRight}\n        />\n      )}\n    </div>\n  );\n};\n"]},"metadata":{},"sourceType":"module"}