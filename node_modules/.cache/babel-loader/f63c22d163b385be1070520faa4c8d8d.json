{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport * as React from 'react';\nimport { useTimeout } from '../../hooks/useTimeout';\n/**\n * Хук, который позволяет управлять видимостью ползунка скроллбара.\n * @param autoHideScrollbar - скрывать ли ползунок скроллбара\n * @param autoHideScrollbarDelay - через какое кол-во миллисекунд ползунок скроллбара скрывается\n * @returns Объект, содержащий параметры, которые позволяют управлять видимостью ползунка\n */\n\nexport var useTrackerVisibility = function useTrackerVisibility() {\n  var autoHideScrollbar = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  var autoHideScrollbarDelay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 500;\n\n  var _React$useState = React.useState(!autoHideScrollbar),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      trackerVisible = _React$useState2[0],\n      setTrackerVisible = _React$useState2[1];\n\n  var isMouseOver = React.useRef(false);\n  var isTrackerDragging = React.useRef(false);\n\n  var _useTimeout = useTimeout(function () {\n    return setTrackerVisible(false);\n  }, autoHideScrollbarDelay),\n      setVisibilityTimeout = _useTimeout.set,\n      clearVisibilityTimeout = _useTimeout.clear;\n\n  var onTrackerDragStart = React.useCallback(function () {\n    clearVisibilityTimeout();\n    setTrackerVisible(true);\n    isTrackerDragging.current = true;\n  }, [clearVisibilityTimeout]);\n  var onTrackerDragStop = React.useCallback(function () {\n    isTrackerDragging.current = false;\n\n    if (!isMouseOver.current) {\n      setVisibilityTimeout();\n    }\n  }, [setVisibilityTimeout, isMouseOver]);\n  /**\n   * Позволяет \"запланировать\" скрытие ползунка через delay миллисекунд. Если тайм-аут не успевает сработать, то каждый\n   * последующий вызов функции откладывает скрытие ползунка на delay миллисекунд\n   */\n\n  var queueTrackerVisibility = React.useCallback(function () {\n    if (isTrackerDragging.current) {\n      return;\n    }\n\n    setTrackerVisible(true);\n    setVisibilityTimeout();\n  }, [setVisibilityTimeout]);\n  var onTrackerMouseEnter = React.useCallback(function () {\n    clearVisibilityTimeout();\n    isMouseOver.current = true;\n    setTrackerVisible(true);\n  }, [clearVisibilityTimeout]);\n  var onTrackerMouseLeave = React.useCallback(function () {\n    queueTrackerVisibility();\n    isMouseOver.current = false;\n  }, [queueTrackerVisibility]);\n  var onTargetScroll = React.useCallback(function () {\n    queueTrackerVisibility();\n  }, [queueTrackerVisibility]);\n  return {\n    trackerVisible: trackerVisible,\n    onTrackerDragStart: onTrackerDragStart,\n    onTrackerDragStop: onTrackerDragStop,\n    onTrackerMouseEnter: onTrackerMouseEnter,\n    onTrackerMouseLeave: onTrackerMouseLeave,\n    onTargetScroll: onTargetScroll\n  };\n};","map":{"version":3,"mappings":";AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,SAASC,UAAT,QAA2B,wBAA3B;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAMC,oBAAoB,GAAG,SAAvBA,oBAAuB,GAGP;EAAA,IAF3BC,iBAAiB,uEAAG,KAEO;EAFF,IACzBC,sBAAsB,uEAAG,GADA;;EAGzB,sBAA4CJ,KAAK,CAACK,QAANL,CAAe,CAACG,iBAAhBH,CAA5C;EAAA,IAA8EM,qDAA9E;EAAA,IAAOC,cAAc,sBAArB;EAAA,IAAuBC,iBAAiB,sBAAxC;;EACA,IAAMC,WAAW,GAAGT,KAAK,CAACU,MAANV,CAAa,KAAbA,CAApB;EACA,IAAMW,iBAAiB,GAAGX,KAAK,CAACU,MAANV,CAAa,KAAbA,CAA1B;;EAEA,kBAAqEC,UAAU,CAC7E;IAAA,OAAMO,iBAAiB,CAAC,KAAD,CAAvB;EAA8B,CAD+C,EAE7EJ,sBAF6E,CAA/E;EAAA,IAAaQ,oBAAoB,eAAzBC,GAAR;EAAA,IAA0CC,sBAAsB,eAA7BC,KAAnC;;EAKA,IAAMC,kBAAkB,GAAGhB,KAAK,CAACiB,WAANjB,CAAkB,YAAM;IACjDc,sBAAsB;IACtBN,iBAAiB,CAAC,IAAD,CAAjBA;IACAG,iBAAiB,CAACO,OAAlBP,GAA4B,IAA5BA;EACD,CAJ0BX,EAIxB,CAACc,sBAAD,CAJwBd,CAA3B;EAMA,IAAMmB,iBAAiB,GAAGnB,KAAK,CAACiB,WAANjB,CAAkB,YAAM;IAChDW,iBAAiB,CAACO,OAAlBP,GAA4B,KAA5BA;;IACA,IAAI,CAACF,WAAW,CAACS,OAAjB,EAA0B;MACxBN,oBAAoB;IACtB;EACD,CALyBZ,EAKvB,CAACY,oBAAD,EAAuBH,WAAvB,CALuBT,CAA1B;EAOA;AACF;AACA;AACA;;EACE,IAAMoB,sBAAsB,GAAGpB,KAAK,CAACiB,WAANjB,CAAkB,YAAM;IACrD,IAAIW,iBAAiB,CAACO,OAAtB,EAA+B;MAC7B;IACF;;IACAV,iBAAiB,CAAC,IAAD,CAAjBA;IACAI,oBAAoB;EACrB,CAN8BZ,EAM5B,CAACY,oBAAD,CAN4BZ,CAA/B;EAQA,IAAMqB,mBAAmB,GAAGrB,KAAK,CAACiB,WAANjB,CAAkB,YAAM;IAClDc,sBAAsB;IACtBL,WAAW,CAACS,OAAZT,GAAsB,IAAtBA;IACAD,iBAAiB,CAAC,IAAD,CAAjBA;EACD,CAJ2BR,EAIzB,CAACc,sBAAD,CAJyBd,CAA5B;EAMA,IAAMsB,mBAAmB,GAAGtB,KAAK,CAACiB,WAANjB,CAAkB,YAAM;IAClDoB,sBAAsB;IACtBX,WAAW,CAACS,OAAZT,GAAsB,KAAtBA;EACD,CAH2BT,EAGzB,CAACoB,sBAAD,CAHyBpB,CAA5B;EAKA,IAAMuB,cAAc,GAAGvB,KAAK,CAACiB,WAANjB,CAAkB,YAAM;IAC7CoB,sBAAsB;EACvB,CAFsBpB,EAEpB,CAACoB,sBAAD,CAFoBpB,CAAvB;EAIA,OAAO;IACLO,cAAc,EAAdA,cADK;IAELS,kBAAkB,EAAlBA,kBAFK;IAGLG,iBAAiB,EAAjBA,iBAHK;IAILE,mBAAmB,EAAnBA,mBAJK;IAKLC,mBAAmB,EAAnBA,mBALK;IAMLC,cAAc,EAAdA;EANK,CAAP;AAQD,CA7DM","names":["React","useTimeout","useTrackerVisibility","autoHideScrollbar","autoHideScrollbarDelay","useState","_React$useState2","trackerVisible","setTrackerVisible","isMouseOver","useRef","isTrackerDragging","setVisibilityTimeout","set","clearVisibilityTimeout","clear","onTrackerDragStart","useCallback","current","onTrackerDragStop","queueTrackerVisibility","onTrackerMouseEnter","onTrackerMouseLeave","onTargetScroll"],"sources":["/Users/pitus_anonimous/Desktop/youth_bit_hack/youth_bit_vk/node_modules/@vkontakte/vkui/src/components/CustomScrollView/useTrackerVisibility.ts"],"sourcesContent":["import * as React from 'react';\nimport { useTimeout } from '../../hooks/useTimeout';\n\n/**\n * Хук, который позволяет управлять видимостью ползунка скроллбара.\n * @param autoHideScrollbar - скрывать ли ползунок скроллбара\n * @param autoHideScrollbarDelay - через какое кол-во миллисекунд ползунок скроллбара скрывается\n * @returns Объект, содержащий параметры, которые позволяют управлять видимостью ползунка\n */\nexport const useTrackerVisibility = (\n  autoHideScrollbar = false,\n  autoHideScrollbarDelay = 500,\n): TrackerVisibilityProps => {\n  const [trackerVisible, setTrackerVisible] = React.useState(!autoHideScrollbar);\n  const isMouseOver = React.useRef(false);\n  const isTrackerDragging = React.useRef(false);\n\n  const { set: setVisibilityTimeout, clear: clearVisibilityTimeout } = useTimeout(\n    () => setTrackerVisible(false),\n    autoHideScrollbarDelay,\n  );\n\n  const onTrackerDragStart = React.useCallback(() => {\n    clearVisibilityTimeout();\n    setTrackerVisible(true);\n    isTrackerDragging.current = true;\n  }, [clearVisibilityTimeout]);\n\n  const onTrackerDragStop = React.useCallback(() => {\n    isTrackerDragging.current = false;\n    if (!isMouseOver.current) {\n      setVisibilityTimeout();\n    }\n  }, [setVisibilityTimeout, isMouseOver]);\n\n  /**\n   * Позволяет \"запланировать\" скрытие ползунка через delay миллисекунд. Если тайм-аут не успевает сработать, то каждый\n   * последующий вызов функции откладывает скрытие ползунка на delay миллисекунд\n   */\n  const queueTrackerVisibility = React.useCallback(() => {\n    if (isTrackerDragging.current) {\n      return;\n    }\n    setTrackerVisible(true);\n    setVisibilityTimeout();\n  }, [setVisibilityTimeout]);\n\n  const onTrackerMouseEnter = React.useCallback(() => {\n    clearVisibilityTimeout();\n    isMouseOver.current = true;\n    setTrackerVisible(true);\n  }, [clearVisibilityTimeout]);\n\n  const onTrackerMouseLeave = React.useCallback(() => {\n    queueTrackerVisibility();\n    isMouseOver.current = false;\n  }, [queueTrackerVisibility]);\n\n  const onTargetScroll = React.useCallback(() => {\n    queueTrackerVisibility();\n  }, [queueTrackerVisibility]);\n\n  return {\n    trackerVisible,\n    onTrackerDragStart,\n    onTrackerDragStop,\n    onTrackerMouseEnter,\n    onTrackerMouseLeave,\n    onTargetScroll,\n  };\n};\n\nexport interface TrackerOptionsProps {\n  /**\n   * Скрывать ли ползунок скроллбара\n   */\n  autoHideScrollbar?: boolean;\n  /**\n   * Через какое кол-во миллисекунд ползунок скроллбара скрывается\n   */\n  autoHideScrollbarDelay?: number;\n}\n\nexport interface TrackerVisibilityProps {\n  /**\n   * Отвечает за видимость ползунка\n   */\n  trackerVisible: boolean;\n  /**\n   * Функция для обработки события у блока со скроллом\n   */\n  onTargetScroll(this: void): void;\n  /**\n   * Функция для обработки начала drag event ползунка\n   */\n  onTrackerDragStart(this: void): void;\n  /**\n   * Функция для обработки окончания drag event ползунка\n   */\n  onTrackerDragStop(this: void): void;\n  /**\n   * Функция для обработки mouseLeave event ползунка\n   */\n  onTrackerMouseEnter(this: void): void;\n  /**\n   * Функция для обработки mouseEnter event ползунка\n   */\n  onTrackerMouseLeave(this: void): void;\n}\n"]},"metadata":{},"sourceType":"module"}